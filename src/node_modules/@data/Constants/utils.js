// @flow

import moment from 'moment';
import 'moment-duration-format';
import R from 'ramda';
import _ from 'lodash';

import type { Moment, Duration } from 'moment';
import type { ApiDayType, DurationType, ApiPeriodType, ApiPeriodTypeType, ApiUserType } from '@data/Resources/ResourcesTypes';

/**
 * check if time is a valid input string
 *
 * Allowed strings are:
 * 12:34
 * 0:30
 * 0,5
 * 0.5
 * ,5
 * 8
 *
 * @param time string
 * @param strict boolean
 * @param allowNegativeValue boolean
 * @returns boolean
 */
export function isValidTimeString(time: string, strict: boolean = true, allowNegativeValue: boolean = false): boolean {
    if (typeof time !== 'string') return false;
    if (!strict && time === '') return true;
    if (time.match(/^(\d+)$/) || (allowNegativeValue && time.match(/^-(\d+)$/))) return true;
    if (allowNegativeValue && time.match(/^-(\d*)[.,:](\d*)$/) !== null) return true;
    return time.match(/^(\d*)[.,:](\d*)$/) !== null;
}

/**
 * get a valid moment object or null if string is not valid
 *
 * used in TimeInput
 *
 * @param time string
 * @param allowNegativeValue boolean
 * @returns {*}
 */
export function getValidMoment(time: string, allowNegativeValue: boolean = false): Duration | null {
    if (!isValidTimeString(time, true, allowNegativeValue)) return null;

    let validTime = null;
    const negative = time.indexOf('-') === 0;
    const absTime = time.substr(negative ? 1 : 0);

    if (absTime.indexOf('.') > -1) {
        validTime = moment.duration(parseFloat(absTime) * 60, 'minutes');
    }
    if (absTime.indexOf(',') > -1) {
        validTime = moment.duration(parseFloat(absTime.replace(',', '.')) * 60, 'minutes');
    }
    if (absTime.indexOf(':') > -1) {
        validTime = moment.duration({ hours: absTime.split(':')[0], minutes: absTime.split(':')[1] });
    }
    if (absTime.match(/^-?(\d*)$/)) {
        validTime = moment.duration({ hours: absTime });
    }

    if (validTime === null || !validTime || !negative) return validTime;

    return moment.duration().subtract(validTime);
}

/**
 * convert a duration object into a dateObject {hours: xx, minutes: yy}
 *
 * used in TimeInput and here
 *
 * @param duration
 * @returns {{hours: *, minutes: *}}
 */
export function getDateObjectFromMomentDuration(duration: Duration): DurationType {
    const days = duration.get('days') * 24;
    const hours = duration.get('hours') + days;
    return {
        hours,
        minutes: duration.get('minutes'),
    };
}

function reduceMomentArray(moments: Array<Moment>, user: ApiUserType): Array<Moment> {
    let startDate = user.usr_employment_start;
    let endDate = user.usr_employment_stop;

    let dates = moments;

    // give one month more time before and after

    if (startDate) {
        startDate = moment(startDate).subtract(1, 'month');
        dates = dates.filter(m => m.isAfter(startDate) || m.isSame(startDate));
    }

    if (endDate) {
        endDate = moment(endDate).add(1, 'month');
        dates = dates.filter(m => m.isBefore(endDate) || m.isSame(endDate));
    }

    return dates;
}

export function getMomentToday(): Moment {
    return moment().startOf('month');
}

/**
 * check if date is without the emploment or more than a year into the future and move user back.
 * @param date
 * @param user
 * @returns {boolean}
 */
export function getNearestDateWithinEmployment(date: Moment, user: ApiUserType): Moment | false {
    let startDate = user.usr_employment_start;
    let endDate = user.usr_employment_stop;
    // give one month more time before and after
    if (startDate) {
        startDate = moment(startDate);
        if (date.isBefore(startDate)) return startDate;
    }

    if (endDate) {
        endDate = moment(endDate);
        if (date.isAfter(endDate)) return endDate;
    } else {
        // check if we want more than a year into the future and stop it
        const today = getMomentToday();
        const future = today.clone().endOf('year').add(1, 'year');
        if (date.isAfter(future)) {
            return today;
        }
    }

    return false;
}

/**
 * check if moment is out of employment scope
 *
 * @param date
 * @param user
 * @returns {boolean}
 */
export function isDateInEmploymentInterval(date: Moment, user: ApiUserType): boolean {
    return getNearestDateWithinEmployment(date, user) === false;
}

/**
 * round example: +15, -15 (in minutes)
 *
 * used in TimeInput
 *
 * @param duration
 * @param round
 *
 * @returns moment.duration
 */
export function roundTime(duration: Duration, round: number): Duration {
    const absRound = Math.abs(round);

    // no need to round
    if (duration.asMinutes() % absRound === 0) return duration;

    const factor = Math.trunc(duration.asMinutes() / absRound);

    const minRounded = factor * absRound;

    const minutes = round > 0 ? minRounded + absRound : minRounded;

    return moment.duration(minutes, 'minutes');
}

export function formatDurationHoursToLocale(time: Duration, fractions: number = 2): string {
    return `${time.asHours().toLocaleString('de-DE', { minimumFractionDigits: fractions })}h`;
}

export function isWeekend(m: Moment): boolean {
    // iso weekday -> 1=monday, 6=saturday, 7=sunday
    return m.isoWeekday() > 5;
}

function durationOfBreak(period: ApiPeriodType): Duration {
    if (!period) return 0;
    return moment.duration(period.per_break || 0);
}

function durationOfWork(period: ApiPeriodType): Duration {
    let ret = moment.duration();
    if (period.per_pty_id === 'Work') {
        const duration = moment.duration(period.per_duration);
        const breakDuration = durationOfBreak(period);

        if (duration.as('ms') > breakDuration.as('ms')) {
            ret = duration.subtract(breakDuration);
        } else {
            ret = moment.duration();
        }
    }
    return ret;
}

function durationOfBalance(period: ApiPeriodType): Duration {
    if (!period || period.per_pty_id !== 'Balance') return 0;
    return moment.duration(period.per_duration || 0);
}

export type WeekNrType = string; // 2001-01

export function weekNr(date: Moment): WeekNrType {
    let nr = date.isoWeek();
    const weekYear = date.isoWeekYear();
    if (nr < 10) {
        nr = `0${nr}`;
    }
    return `${weekYear}-${nr}`;
}

function sumDuration(xs: Array<Duration>): Duration {
    return xs.reduce((total, x) => total.add(x), moment.duration());
}

/**
 * returns a moment.duration object or null
 * todo: remove
 *
 * @param obj
 * @param attr
 * @returns {moment.duration|null}
 */
function getMomentFromImmutable(obj: Object, attr: string): Duration | null {
    return obj[attr] ? moment.duration(obj[attr]) : null;
}

/**
 * get Year Array of Moments for a specific user
 *
 * @param user
 * @param _today moment
 * @param limit optional, defaults to 6
 */
export function getYearsForUser(user: ApiUserType, _today: Moment, limit: number = 6): Array<Moment> {
    let today2 = _today;

    if (!moment.isMoment(today2)) {
        throw new Error('getYearsForUser expects a Today Object!');
    }

    // adjust today for starters
    let startDate = user.usr_employment_start;

    if (startDate) {
        startDate = moment(startDate);
        today2 = today2.clone().month(startDate.month()).day(startDate.day()).add(1, 'day');
    }

    const years = _.times(limit, i => today2.clone().add(1, 'year').subtract(i, 'years'));

    // eslint-disable-next-line new-cap
    return reduceMomentArray(years, user);
}

/**
 * get month array for moments for a specific user
 *
 * used in MonthView.js
 *
 * @param user
 * @param activeMonth moment
 * @returns Array<Moment>
 */
export function getMonthsForUser(user: ApiUserType, activeMonth: Moment): Array<Moment> {
    const months = _.times(12, n => activeMonth.clone().month(n));
    return reduceMomentArray(months, user);
}

export type DurationVariantType = 'period' | 'fullday' | 'halfday' | 'duration' | 'none'; // todo none?
function getDurationType(period: ApiPeriodType, targetTime: DurationType, type: ApiPeriodTypeType): DurationVariantType {
    const cfg = type.pty_config.types;

    if (period.per_id !== null) {
        const start = period.per_start;
        const duration = moment.duration(period.per_duration);
        const target = moment.duration(targetTime);

        if (cfg.period && start && moment.duration(start).as('minutes') >= 0) return 'period';
        if (cfg.halfday && duration.as('hours') === (target.as('hours') / 2)) return 'halfday';
        if (cfg.fullday && duration.as('hours') === target.as('hours')) return 'fullday';
        if (cfg.duration) return 'duration';
    } else {
        if (cfg.period) return 'period';
        if (cfg.fullday) return 'fullday';
        if (cfg.halfday) return 'halfday';
        if (cfg.duration) return 'duration';
    }

    return 'none';
}

export type ProcessedPeriodType = ApiPeriodType & {
    type: ApiPeriodTypeType,
    duration: DurationVariantType,
};

function assocPeriodWithType(typeMap: Object, targetTime: DurationType, period: ApiPeriodType): ProcessedPeriodType {
    const type = typeMap[period.per_pty_id]; // ApiPeriodTypeType
    const duration = getDurationType(period, targetTime, type);
    return {
        ...period,
        type,
        duration,
    };
}

export type AssocDayType = {
    ...ApiDayType,
    periods: Array<ProcessedPeriodType>,
};
export function assocPeriodsWithTypes(types: Array<ApiPeriodTypeType>, days: Array<ApiDayType>): Array<AssocDayType> {
    const typeMap = R.compose(
        R.map(R.head),
        R.groupBy(type => type.pty_id),
    )(types);

    // updateIn periods
    return [...R.map(day => ({
        ...day,
        periods: R.map(R.curry(assocPeriodWithType)(typeMap, day.day_target_time))(day.periods),
    }))(days)];
}

function periodUnfinished(period: ApiPeriodType): boolean {
    return !!period.per_start === !!period.per_stop;
}

export type ProcessedDayType = AssocDayType & {
    weekNr: WeekNrType,
    date: Moment,
    day_target_time: Duration,
    remaining: Duration,
    remainingUntilToday: Duration,
    workDuration: Duration,
    breakDuration: Duration,
    balanceDuration: Duration,
    isUnfinished: boolean,
};
function processDay(day: AssocDayType): ProcessedDayType {
    const date = moment(day.day_date);
    const today = moment();
    const remaining = moment.duration(day.remaining);

    return {
        ...day,
        weekNr: weekNr(date),
        date,
        day_target_time: moment.duration(day.day_target_time),
        remaining,
        remainingUntilToday: date <= today ? remaining : moment.duration(),
        workDuration: sumDuration(day.periods.map(per => durationOfWork(per))),
        breakDuration: sumDuration(day.periods.map(per => durationOfBreak(per))),
        balanceDuration: sumDuration(day.periods.map(per => durationOfBalance(per))),
        isUnfinished: date.isBefore(moment(), 'day') && !R.all(periodUnfinished)(day.periods),
    };
}

export type ProcessedWeekType = {
    days: Array<ProcessedDayType>,
    weekNr: WeekNrType,
    workDuration: Duration,
    balanceDuration: Duration,
    targetDuration: Duration,
    diff: Duration,
    diffUntilToday: Duration,
    carry: Duration,
};
function processWeek(carry: Duration, weekDays: Array<ProcessedDayType>, weekNumber: WeekNrType): ProcessedWeekType {
    const workDuration = sumDuration(weekDays.map(day => day.workDuration));
    const balanceDuration = sumDuration(weekDays.map(day => day.balanceDuration));
    const targetDuration = sumDuration(weekDays.map(day => day.remaining));
    const targetDurationUntilToday = sumDuration(weekDays.map(day => day.remainingUntilToday));
    const diff = moment.duration(workDuration).subtract(targetDuration);
    const diffUntilToday = moment.duration(workDuration).subtract(targetDurationUntilToday);
    carry.add(diffUntilToday);

    return {
        days: weekDays,
        weekNr: weekNumber,
        workDuration,
        balanceDuration,
        targetDuration,
        diff,
        diffUntilToday,
        carry: moment.duration(carry),
    };
}

/**
 * todo: add flag to data structure while processing week
 * @param week
 * @returns {boolean}
 */
export function isWeekInFuture(week: ProcessedWeekType): boolean {
    return week.weekNr > moment().format('YYYY-w');
}

export function createWeeks(days: ApiDayType, carryTime: DurationType): Array<ProcessedWeekType> {
    const carry = moment.duration(carryTime);
    return R.compose(
        R.mapObjIndexed(R.curry(processWeek)(carry)),
        R.groupBy(day => day.weekNr),
        R.map(processDay),
    )(days);
}

/**
 *
 * PERIOD UTILS
 *
 */

/**
 * Duration Type Config Names
 * todo: Type DurationVariantType
 */
export const NONE = 'none';
export const PERIOD = 'period';
export const HALFDAY = 'halfday';
export const FULLDAY = 'fullday';
export const DURATION = 'duration';

/**
 * Duration Config
 */
export type DurationConfigType = {
    name: DurationVariantType,
    description: string,
};
export const durationConfig: Array<DurationConfigType> = [
    { name: PERIOD, description: 'Zeitraum' },
    { name: FULLDAY, description: 'Ganzer Tag' },
    { name: HALFDAY, description: 'Halber Tag' },
    { name: DURATION, description: 'Zeitdauer' },
];

/**
 * get Duration Description from name
 * @param name
 * @returns {*}
 */
export function getDurationDescription(name: DurationVariantType): string {
    return (durationConfig.find(cfg => cfg.name === name) || {}).description;
}

/**
 * calculate duration based on the period. returns the DateObject
 *
 * @param period
 * @param fullDay
 * @returns {*}
 */
export function calculateDuration(period: ProcessedPeriodType, fullDay: Duration): DurationType {
    const halfDay = moment.duration(Math.round(fullDay.asSeconds() / 2), 's');
    const name = period.duration;

    if (name === FULLDAY) return getDateObjectFromMomentDuration(fullDay);
    if (name === HALFDAY) return getDateObjectFromMomentDuration(halfDay);
    if (name === DURATION) return period.per_duration;
    if (name === NONE) return { hours: 0 };

    if (!period.per_start || !period.per_stop) return {};

    const startTime = moment.duration(period.per_start);
    const stopTime = moment.duration(period.per_stop);

    return getDateObjectFromMomentDuration(stopTime.subtract(startTime));
}

function getBreakTime(period: ProcessedPeriodType): number {
    return moment.duration(period.per_break)
        .as('minutes');
}

function getWorkedTime(period: ProcessedPeriodType): number {
    return moment.duration(period.per_stop)
        .subtract(moment.duration(period.per_start))
        .as('minutes');
}

/**
 * compare break length to work length
 * @param period
 * @returns {boolean}
 */
function isBreakLengthValid(period: ProcessedPeriodType): boolean {
    if (!getBreakTime(period)) return true;
    return getWorkedTime(period) >= getBreakTime(period);
}

/**
 *
 * checks if any periods are overlapping withing given day.
 *
 * @param periods
 * @returns {boolean}
 */
export function isOverlapping(periods: Array<ProcessedPeriodType>): boolean {
    if (periods.length <= 1) {
        return false;
    }
    return !R.all((period, index) => {
        const startTime = getMomentFromImmutable(period, 'per_start');
        const stopTime = getMomentFromImmutable(period, 'per_stop');

        // if no startTime then there is nothing to do
        if (startTime === null) return true;

        return R.all((p, i) => {
            // don't check myself
            if (i === index) return true;

            const pStartTime = getMomentFromImmutable(p, 'per_start');
            const pStopTime = getMomentFromImmutable(p, 'per_stop');

            // if no startTime then there is nothing to do
            if (pStartTime === null) return true;

            // check good case
            if (stopTime && pStartTime >= stopTime) return true;
            if (pStopTime && startTime >= pStopTime) return true;

            // check not good case
            if (stopTime && pStartTime >= startTime && pStartTime <= stopTime) return false;
            if (pStopTime && startTime >= pStartTime && startTime <= pStopTime) return false;

            return true;
        });

        // periods.every();
    })(periods);

    /*     periodList.every((period, index) => {
            const startTime = getMomentFromImmutable(period, 'per_start');
            const stopTime = getMomentFromImmutable(period, 'per_stop');

            // if no startTime then there is nothing to do
            if (startTime === null) return true;

            return periods.every((p, i) => {
                // don't check myself
                if (i === index) return true;

                const pStartTime = getMomentFromImmutable(p, 'per_start');
                const pStopTime = getMomentFromImmutable(p, 'per_stop');

                // if no startTime then there is nothing to do
                if (pStartTime === null) return true;

                // check good case
                if (stopTime && pStartTime >= stopTime) return true;
                if (pStopTime && startTime >= pStopTime) return true;

                // check not good case
                if (stopTime && pStartTime >= startTime && pStartTime <= stopTime) return false;
                if (pStopTime && startTime >= pStartTime && startTime <= pStopTime) return false;

                return true;
            });
        }); */
}

export function validatePeriod(period: ProcessedPeriodType): boolean {
    if (!period || !R.is(Object)(period)) return false;
    if (period.duration === FULLDAY) return true;
    if (period.duration === HALFDAY) return true;
    if (period.duration === DURATION) return true;
    // new Periods dont contain type propertie
    const typeConfig = R.pathOr(false, ['type', 'pty_config', 'types'])(period);

    // Some thest dont work because this
    if (!typeConfig) return false;

    // if there is no duration needed, don't ask for one (comment type for example)
    if (period.duration === NONE && !R.all((t => t))(typeConfig)) return true;

    let startTime = period.per_start;
    let endTime = period.per_stop;
    const breakTime = period.per_break || false;

    if (!startTime) return false;

    startTime = moment.duration(startTime);

    if (endTime) {
        endTime = moment.duration(endTime);
        if (endTime < startTime) return false;
        if (breakTime && !isBreakLengthValid(period)) return false;
    }

    return true;
}

/**
 *
 * @param period
 * @returns {Array}
 */
export function getAllErrors(period: ProcessedPeriodType): Array<string> {
    if (!period || validatePeriod(period)) return [];

    if (period.duration === FULLDAY) return [];
    if (period.duration === HALFDAY) return [];
    if (period.duration === DURATION) return [];

    let startTime = period.per_start;
    let endTime = period.per_stop;
    const breakTime = period.per_break || false;

    const errors = [];

    if (!startTime) {
        errors.push('Die Startzeit muss angegeben werden!');
    } else {
        startTime = moment.duration(startTime);

        if (endTime) {
            endTime = moment.duration(endTime);
            if (endTime < startTime) {
                errors.push('Wenn vorhanden muss die Endzeit nach der Startzeit liegen!');
            }
            if (breakTime && !isBreakLengthValid(period)) {
                errors.push('Die Pause ist zu lang!');
            }
        }
    }

    return errors;
}


/**
 * validate a list of periods
 *
 * validates each of the periods and also checks for overlapping times
 *
 * @param periods
 * @returns {*|boolean}
 */
export function validatePeriods(periods: Array<ProcessedPeriodType>): boolean {
    // validate every period
    const valid = R.all(validatePeriod)(periods);
    if (!valid) return valid;

    // if everything is valid, also check for overlapping
    return !isOverlapping(periods);
}
