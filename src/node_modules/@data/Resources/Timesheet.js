/* eslint-disable function-paren-newline */
// @flow

import R from 'ramda';
import moment from 'moment';
import { config } from '../Constants';

const { client } = config;

const postPeriods = R.curry((usr_id, payload) => client.post(`users/${usr_id}/periods/`, payload));

const updatePeriods = R.curry((usr_id, per_id, payload) => client.put(`users/${usr_id}/periods/${per_id}`, payload));

const deletePeriods = R.curry((usr_id, per_id) => client.delete(`users/${usr_id}/periods/${per_id}`));

const fixDurations = (period) => {
    const durations = ['per_start', 'per_stop', 'per_duration', 'per_break'];
    return R.mapObjIndexed(
        (val, key) => (R.contains(key, durations) && val !== null ? moment.duration(val) : val),
    )(period);
};

export const Timesheet = {
    getTypes: () => client.get('period-types'),
    // TODO naming ...
    getTimesheetFromUser: (user, from, to) => client.get(`users/${user.usr_id}/timesheet/${from}/${to}`),
    saveDay: async (usr_id, date, periods, removed) => {
        const postPeriodsCurried = postPeriods(usr_id);
        const updatePeriodsCurried = updatePeriods(usr_id);
        const deletePeriodsCurried = deletePeriods(usr_id);

        const createOrUpdatePromises = R.map((period) => {
            const payload = fixDurations({
                ...period,
                date: date.format('YYYY-MM-DD'),
                usr_id,
                per_pty_id: period.type.pty_id,
            });

            if (payload.per_id) return updatePeriodsCurried(payload.per_id, payload);
            return postPeriodsCurried(payload);
        })(periods);

        const removePeriodsPromises = R.map(deletePeriodsCurried)(removed);

        return Promise.all([
            ...createOrUpdatePromises,
            ...removePeriodsPromises,
        ]);
    },
};
